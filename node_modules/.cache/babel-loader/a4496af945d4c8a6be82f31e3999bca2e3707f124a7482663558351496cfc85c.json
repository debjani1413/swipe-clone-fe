{"ast":null,"code":"import { readFileSync } from 'fs';\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Basic error type for this SDK.\n * @public\n */\nclass GoogleGenerativeAIError extends Error {\n  constructor(message) {\n    super(`[GoogleGenerativeAI Error]: ${message}`);\n  }\n}\n/**\n * Error class covering HTTP errors when calling the server. Includes HTTP\n * status, statusText, and optional details, if provided in the server response.\n * @public\n */\nclass GoogleGenerativeAIFetchError extends GoogleGenerativeAIError {\n  constructor(message, status, statusText, errorDetails) {\n    super(message);\n    this.status = status;\n    this.statusText = statusText;\n    this.errorDetails = errorDetails;\n  }\n}\n/**\n * Errors in the contents of a request originating from user input.\n * @public\n */\nclass GoogleGenerativeAIRequestInputError extends GoogleGenerativeAIError {}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_BASE_URL = \"https://generativelanguage.googleapis.com\";\nconst DEFAULT_API_VERSION = \"v1beta\";\n/**\n * We can't `require` package.json if this runs on web. We will use rollup to\n * swap in the version number here at build time.\n */\nconst PACKAGE_VERSION = \"0.21.0\";\nconst PACKAGE_LOG_HEADER = \"genai-js\";\nvar Task;\n(function (Task) {\n  Task[\"GENERATE_CONTENT\"] = \"generateContent\";\n  Task[\"STREAM_GENERATE_CONTENT\"] = \"streamGenerateContent\";\n  Task[\"COUNT_TOKENS\"] = \"countTokens\";\n  Task[\"EMBED_CONTENT\"] = \"embedContent\";\n  Task[\"BATCH_EMBED_CONTENTS\"] = \"batchEmbedContents\";\n})(Task || (Task = {}));\n/**\n * Simple, but may become more complex if we add more versions to log.\n */\nfunction getClientHeaders(requestOptions) {\n  const clientHeaders = [];\n  if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {\n    clientHeaders.push(requestOptions.apiClient);\n  }\n  clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);\n  return clientHeaders.join(\" \");\n}\nasync function makeRequest(url, fetchOptions, fetchFn = fetch) {\n  let response;\n  try {\n    response = await fetchFn(url, fetchOptions);\n  } catch (e) {\n    handleResponseError(e, url);\n  }\n  if (!response.ok) {\n    await handleResponseNotOk(response, url);\n  }\n  return response;\n}\nfunction handleResponseError(e, url) {\n  let err = e;\n  if (!(e instanceof GoogleGenerativeAIFetchError || e instanceof GoogleGenerativeAIRequestInputError)) {\n    err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);\n    err.stack = e.stack;\n  }\n  throw err;\n}\nasync function handleResponseNotOk(response, url) {\n  let message = \"\";\n  let errorDetails;\n  try {\n    const json = await response.json();\n    message = json.error.message;\n    if (json.error.details) {\n      message += ` ${JSON.stringify(json.error.details)}`;\n      errorDetails = json.error.details;\n    }\n  } catch (e) {\n    // ignored\n  }\n  throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar RpcTask;\n(function (RpcTask) {\n  RpcTask[\"UPLOAD\"] = \"upload\";\n  RpcTask[\"LIST\"] = \"list\";\n  RpcTask[\"GET\"] = \"get\";\n  RpcTask[\"DELETE\"] = \"delete\";\n  RpcTask[\"UPDATE\"] = \"update\";\n  RpcTask[\"CREATE\"] = \"create\";\n})(RpcTask || (RpcTask = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst taskToMethod = {\n  [RpcTask.UPLOAD]: \"POST\",\n  [RpcTask.LIST]: \"GET\",\n  [RpcTask.GET]: \"GET\",\n  [RpcTask.DELETE]: \"DELETE\",\n  [RpcTask.UPDATE]: \"PATCH\",\n  [RpcTask.CREATE]: \"POST\"\n};\nclass ServerRequestUrl {\n  constructor(task, apiKey, requestOptions) {\n    this.task = task;\n    this.apiKey = apiKey;\n    this.requestOptions = requestOptions;\n  }\n  appendPath(path) {\n    this._url.pathname = this._url.pathname + `/${path}`;\n  }\n  appendParam(key, value) {\n    this._url.searchParams.append(key, value);\n  }\n  toString() {\n    return this._url.toString();\n  }\n}\nclass CachedContentUrl extends ServerRequestUrl {\n  constructor(task, apiKey, requestOptions) {\n    var _a, _b;\n    super(task, apiKey, requestOptions);\n    this.task = task;\n    this.apiKey = apiKey;\n    this.requestOptions = requestOptions;\n    const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;\n    const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;\n    let initialUrl = baseUrl;\n    initialUrl += `/${apiVersion}/cachedContents`;\n    this._url = new URL(initialUrl);\n  }\n}\nclass FilesRequestUrl extends ServerRequestUrl {\n  constructor(task, apiKey, requestOptions) {\n    var _a, _b;\n    super(task, apiKey, requestOptions);\n    this.task = task;\n    this.apiKey = apiKey;\n    this.requestOptions = requestOptions;\n    const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;\n    const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;\n    let initialUrl = baseUrl;\n    if (this.task === RpcTask.UPLOAD) {\n      initialUrl += `/upload`;\n    }\n    initialUrl += `/${apiVersion}/files`;\n    this._url = new URL(initialUrl);\n  }\n}\nfunction getHeaders(url) {\n  const headers = new Headers();\n  headers.append(\"x-goog-api-client\", getClientHeaders(url.requestOptions));\n  headers.append(\"x-goog-api-key\", url.apiKey);\n  return headers;\n}\nasync function makeServerRequest(url, headers, body, fetchFn = fetch) {\n  const requestInit = {\n    method: taskToMethod[url.task],\n    headers\n  };\n  if (body) {\n    requestInit.body = body;\n  }\n  const signal = getSignal(url.requestOptions);\n  if (signal) {\n    requestInit.signal = signal;\n  }\n  return makeRequest(url.toString(), requestInit, fetchFn);\n}\n/**\n * Create an AbortSignal based on the timeout and signal in the\n * RequestOptions.\n */\nfunction getSignal(requestOptions) {\n  if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) !== undefined || (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {\n    const controller = new AbortController();\n    if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {\n      setTimeout(() => controller.abort(), requestOptions.timeout);\n    }\n    if (requestOptions.signal) {\n      requestOptions.signal.addEventListener(\"abort\", () => {\n        controller.abort();\n      });\n    }\n    return controller.signal;\n  }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Class for managing GoogleAI file uploads.\n * @public\n */\nclass GoogleAIFileManager {\n  constructor(apiKey, _requestOptions = {}) {\n    this.apiKey = apiKey;\n    this._requestOptions = _requestOptions;\n  }\n  /**\n   * Upload a file.\n   */\n  async uploadFile(filePath, fileMetadata) {\n    const file = readFileSync(filePath);\n    const url = new FilesRequestUrl(RpcTask.UPLOAD, this.apiKey, this._requestOptions);\n    const uploadHeaders = getHeaders(url);\n    const boundary = generateBoundary();\n    uploadHeaders.append(\"X-Goog-Upload-Protocol\", \"multipart\");\n    uploadHeaders.append(\"Content-Type\", `multipart/related; boundary=${boundary}`);\n    const uploadMetadata = getUploadMetadata(fileMetadata);\n    // Multipart formatting code taken from @firebase/storage\n    const metadataString = JSON.stringify({\n      file: uploadMetadata\n    });\n    const preBlobPart = \"--\" + boundary + \"\\r\\n\" + \"Content-Type: application/json; charset=utf-8\\r\\n\\r\\n\" + metadataString + \"\\r\\n--\" + boundary + \"\\r\\n\" + \"Content-Type: \" + fileMetadata.mimeType + \"\\r\\n\\r\\n\";\n    const postBlobPart = \"\\r\\n--\" + boundary + \"--\";\n    const blob = new Blob([preBlobPart, file, postBlobPart]);\n    const response = await makeServerRequest(url, uploadHeaders, blob);\n    return response.json();\n  }\n  /**\n   * List all uploaded files.\n   *\n   * Any fields set in the optional {@link SingleRequestOptions} parameter will take\n   * precedence over the {@link RequestOptions} values provided at the time of the\n   * {@link GoogleAIFileManager} initialization.\n   */\n  async listFiles(listParams, requestOptions = {}) {\n    const filesRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n    const url = new FilesRequestUrl(RpcTask.LIST, this.apiKey, filesRequestOptions);\n    if (listParams === null || listParams === void 0 ? void 0 : listParams.pageSize) {\n      url.appendParam(\"pageSize\", listParams.pageSize.toString());\n    }\n    if (listParams === null || listParams === void 0 ? void 0 : listParams.pageToken) {\n      url.appendParam(\"pageToken\", listParams.pageToken);\n    }\n    const uploadHeaders = getHeaders(url);\n    const response = await makeServerRequest(url, uploadHeaders);\n    return response.json();\n  }\n  /**\n   * Get metadata for file with given ID.\n   *\n   * Any fields set in the optional {@link SingleRequestOptions} parameter will take\n   * precedence over the {@link RequestOptions} values provided at the time of the\n   * {@link GoogleAIFileManager} initialization.\n   */\n  async getFile(fileId, requestOptions = {}) {\n    const filesRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n    const url = new FilesRequestUrl(RpcTask.GET, this.apiKey, filesRequestOptions);\n    url.appendPath(parseFileId(fileId));\n    const uploadHeaders = getHeaders(url);\n    const response = await makeServerRequest(url, uploadHeaders);\n    return response.json();\n  }\n  /**\n   * Delete file with given ID.\n   */\n  async deleteFile(fileId) {\n    const url = new FilesRequestUrl(RpcTask.DELETE, this.apiKey, this._requestOptions);\n    url.appendPath(parseFileId(fileId));\n    const uploadHeaders = getHeaders(url);\n    await makeServerRequest(url, uploadHeaders);\n  }\n}\n/**\n * If fileId is prepended with \"files/\", remove prefix\n */\nfunction parseFileId(fileId) {\n  if (fileId.startsWith(\"files/\")) {\n    return fileId.split(\"files/\")[1];\n  }\n  if (!fileId) {\n    throw new GoogleGenerativeAIError(`Invalid fileId ${fileId}. ` + `Must be in the format \"files/filename\" or \"filename\"`);\n  }\n  return fileId;\n}\nfunction generateBoundary() {\n  let str = \"\";\n  for (let i = 0; i < 2; i++) {\n    str = str + Math.random().toString().slice(2);\n  }\n  return str;\n}\nfunction getUploadMetadata(inputMetadata) {\n  if (!inputMetadata.mimeType) {\n    throw new GoogleGenerativeAIRequestInputError(\"Must provide a mimeType.\");\n  }\n  const uploadMetadata = {\n    mimeType: inputMetadata.mimeType,\n    displayName: inputMetadata.displayName\n  };\n  if (inputMetadata.name) {\n    uploadMetadata.name = inputMetadata.name.includes(\"/\") ? inputMetadata.name : `files/${inputMetadata.name}`;\n  }\n  return uploadMetadata;\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction formatSystemInstruction(input) {\n  // null or undefined\n  if (input == null) {\n    return undefined;\n  } else if (typeof input === \"string\") {\n    return {\n      role: \"system\",\n      parts: [{\n        text: input\n      }]\n    };\n  } else if (input.text) {\n    return {\n      role: \"system\",\n      parts: [input]\n    };\n  } else if (input.parts) {\n    if (!input.role) {\n      return {\n        role: \"system\",\n        parts: input.parts\n      };\n    } else {\n      return input;\n    }\n  }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Class for managing GoogleAI content caches.\n * @public\n */\nclass GoogleAICacheManager {\n  constructor(apiKey, _requestOptions) {\n    this.apiKey = apiKey;\n    this._requestOptions = _requestOptions;\n  }\n  /**\n   * Upload a new content cache\n   */\n  async create(createOptions) {\n    const newCachedContent = Object.assign({}, createOptions);\n    if (createOptions.ttlSeconds) {\n      if (createOptions.expireTime) {\n        throw new GoogleGenerativeAIRequestInputError(\"You cannot specify both `ttlSeconds` and `expireTime` when creating\" + \" a content cache. You must choose one.\");\n      }\n      if (createOptions.systemInstruction) {\n        newCachedContent.systemInstruction = formatSystemInstruction(createOptions.systemInstruction);\n      }\n      newCachedContent.ttl = createOptions.ttlSeconds.toString() + \"s\";\n      delete newCachedContent.ttlSeconds;\n    }\n    if (!newCachedContent.model) {\n      throw new GoogleGenerativeAIRequestInputError(\"Cached content must contain a `model` field.\");\n    }\n    if (!newCachedContent.model.includes(\"/\")) {\n      // If path is not included, assume it's a non-tuned model.\n      newCachedContent.model = `models/${newCachedContent.model}`;\n    }\n    const url = new CachedContentUrl(RpcTask.CREATE, this.apiKey, this._requestOptions);\n    const headers = getHeaders(url);\n    const response = await makeServerRequest(url, headers, JSON.stringify(newCachedContent));\n    return response.json();\n  }\n  /**\n   * List all uploaded content caches\n   */\n  async list(listParams) {\n    const url = new CachedContentUrl(RpcTask.LIST, this.apiKey, this._requestOptions);\n    if (listParams === null || listParams === void 0 ? void 0 : listParams.pageSize) {\n      url.appendParam(\"pageSize\", listParams.pageSize.toString());\n    }\n    if (listParams === null || listParams === void 0 ? void 0 : listParams.pageToken) {\n      url.appendParam(\"pageToken\", listParams.pageToken);\n    }\n    const headers = getHeaders(url);\n    const response = await makeServerRequest(url, headers);\n    return response.json();\n  }\n  /**\n   * Get a content cache\n   */\n  async get(name) {\n    const url = new CachedContentUrl(RpcTask.GET, this.apiKey, this._requestOptions);\n    url.appendPath(parseCacheName(name));\n    const headers = getHeaders(url);\n    const response = await makeServerRequest(url, headers);\n    return response.json();\n  }\n  /**\n   * Update an existing content cache\n   */\n  async update(name, updateParams) {\n    const url = new CachedContentUrl(RpcTask.UPDATE, this.apiKey, this._requestOptions);\n    url.appendPath(parseCacheName(name));\n    const headers = getHeaders(url);\n    const formattedCachedContent = Object.assign({}, updateParams.cachedContent);\n    if (updateParams.cachedContent.ttlSeconds) {\n      formattedCachedContent.ttl = updateParams.cachedContent.ttlSeconds.toString() + \"s\";\n      delete formattedCachedContent.ttlSeconds;\n    }\n    if (updateParams.updateMask) {\n      url.appendParam(\"update_mask\", updateParams.updateMask.map(prop => camelToSnake(prop)).join(\",\"));\n    }\n    const response = await makeServerRequest(url, headers, JSON.stringify(formattedCachedContent));\n    return response.json();\n  }\n  /**\n   * Delete content cache with given name\n   */\n  async delete(name) {\n    const url = new CachedContentUrl(RpcTask.DELETE, this.apiKey, this._requestOptions);\n    url.appendPath(parseCacheName(name));\n    const headers = getHeaders(url);\n    await makeServerRequest(url, headers);\n  }\n}\n/**\n * If cache name is prepended with \"cachedContents/\", remove prefix\n */\nfunction parseCacheName(name) {\n  if (name.startsWith(\"cachedContents/\")) {\n    return name.split(\"cachedContents/\")[1];\n  }\n  if (!name) {\n    throw new GoogleGenerativeAIError(`Invalid name ${name}. ` + `Must be in the format \"cachedContents/name\" or \"name\"`);\n  }\n  return name;\n}\nfunction camelToSnake(str) {\n  return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);\n}\n\n/**\n * Processing state of the `File`.\n * @public\n */\nvar FileState;\n(function (FileState) {\n  // The default value. This value is used if the state is omitted.\n  FileState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n  // File is being processed and cannot be used for inference yet.\n  FileState[\"PROCESSING\"] = \"PROCESSING\";\n  // File is processed and available for inference.\n  FileState[\"ACTIVE\"] = \"ACTIVE\";\n  // File failed processing.\n  FileState[\"FAILED\"] = \"FAILED\";\n})(FileState || (FileState = {}));\n\n/**\n * Contains the list of OpenAPI data types\n * as defined by https://swagger.io/docs/specification/data-models/data-types/\n * @public\n */\nvar SchemaType;\n(function (SchemaType) {\n  /** String type. */\n  SchemaType[\"STRING\"] = \"string\";\n  /** Number type. */\n  SchemaType[\"NUMBER\"] = \"number\";\n  /** Integer type. */\n  SchemaType[\"INTEGER\"] = \"integer\";\n  /** Boolean type. */\n  SchemaType[\"BOOLEAN\"] = \"boolean\";\n  /** Array type. */\n  SchemaType[\"ARRAY\"] = \"array\";\n  /** Object type. */\n  SchemaType[\"OBJECT\"] = \"object\";\n})(SchemaType || (SchemaType = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @public\n */\nvar ExecutableCodeLanguage;\n(function (ExecutableCodeLanguage) {\n  ExecutableCodeLanguage[\"LANGUAGE_UNSPECIFIED\"] = \"language_unspecified\";\n  ExecutableCodeLanguage[\"PYTHON\"] = \"python\";\n})(ExecutableCodeLanguage || (ExecutableCodeLanguage = {}));\n/**\n * Possible outcomes of code execution.\n * @public\n */\nvar Outcome;\n(function (Outcome) {\n  /**\n   * Unspecified status. This value should not be used.\n   */\n  Outcome[\"OUTCOME_UNSPECIFIED\"] = \"outcome_unspecified\";\n  /**\n   * Code execution completed successfully.\n   */\n  Outcome[\"OUTCOME_OK\"] = \"outcome_ok\";\n  /**\n   * Code execution finished but with a failure. `stderr` should contain the\n   * reason.\n   */\n  Outcome[\"OUTCOME_FAILED\"] = \"outcome_failed\";\n  /**\n   * Code execution ran for too long, and was cancelled. There may or may not\n   * be a partial output present.\n   */\n  Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"outcome_deadline_exceeded\";\n})(Outcome || (Outcome = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Possible roles.\n * @public\n */\n/**\n * Harm categories that would cause prompts or candidates to be blocked.\n * @public\n */\nvar HarmCategory;\n(function (HarmCategory) {\n  HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n  HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n  HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n  HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n  HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n})(HarmCategory || (HarmCategory = {}));\n/**\n * Threshold above which a prompt or candidate will be blocked.\n * @public\n */\nvar HarmBlockThreshold;\n(function (HarmBlockThreshold) {\n  // Threshold is unspecified.\n  HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n  // Content with NEGLIGIBLE will be allowed.\n  HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n  // Content with NEGLIGIBLE and LOW will be allowed.\n  HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n  // Content with NEGLIGIBLE, LOW, and MEDIUM will be allowed.\n  HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n  // All content will be allowed.\n  HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(HarmBlockThreshold || (HarmBlockThreshold = {}));\n/**\n * Probability that a prompt or candidate matches a harm category.\n * @public\n */\nvar HarmProbability;\n(function (HarmProbability) {\n  // Probability is unspecified.\n  HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n  // Content has a negligible chance of being unsafe.\n  HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n  // Content has a low chance of being unsafe.\n  HarmProbability[\"LOW\"] = \"LOW\";\n  // Content has a medium chance of being unsafe.\n  HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n  // Content has a high chance of being unsafe.\n  HarmProbability[\"HIGH\"] = \"HIGH\";\n})(HarmProbability || (HarmProbability = {}));\n/**\n * Reason that a prompt was blocked.\n * @public\n */\nvar BlockReason;\n(function (BlockReason) {\n  // A blocked reason was not specified.\n  BlockReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n  // Content was blocked by safety settings.\n  BlockReason[\"SAFETY\"] = \"SAFETY\";\n  // Content was blocked, but the reason is uncategorized.\n  BlockReason[\"OTHER\"] = \"OTHER\";\n})(BlockReason || (BlockReason = {}));\n/**\n * Reason that a candidate finished.\n * @public\n */\nvar FinishReason;\n(function (FinishReason) {\n  // Default value. This value is unused.\n  FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n  // Natural stop point of the model or provided stop sequence.\n  FinishReason[\"STOP\"] = \"STOP\";\n  // The maximum number of tokens as specified in the request was reached.\n  FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n  // The candidate content was flagged for safety reasons.\n  FinishReason[\"SAFETY\"] = \"SAFETY\";\n  // The candidate content was flagged for recitation reasons.\n  FinishReason[\"RECITATION\"] = \"RECITATION\";\n  // The candidate content was flagged for using an unsupported language.\n  FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n  // Unknown reason.\n  FinishReason[\"OTHER\"] = \"OTHER\";\n})(FinishReason || (FinishReason = {}));\n/**\n * Task type for embedding content.\n * @public\n */\nvar TaskType;\n(function (TaskType) {\n  TaskType[\"TASK_TYPE_UNSPECIFIED\"] = \"TASK_TYPE_UNSPECIFIED\";\n  TaskType[\"RETRIEVAL_QUERY\"] = \"RETRIEVAL_QUERY\";\n  TaskType[\"RETRIEVAL_DOCUMENT\"] = \"RETRIEVAL_DOCUMENT\";\n  TaskType[\"SEMANTIC_SIMILARITY\"] = \"SEMANTIC_SIMILARITY\";\n  TaskType[\"CLASSIFICATION\"] = \"CLASSIFICATION\";\n  TaskType[\"CLUSTERING\"] = \"CLUSTERING\";\n})(TaskType || (TaskType = {}));\n/**\n * @public\n */\nvar FunctionCallingMode;\n(function (FunctionCallingMode) {\n  // Unspecified function calling mode. This value should not be used.\n  FunctionCallingMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n  // Default model behavior, model decides to predict either a function call\n  // or a natural language repspose.\n  FunctionCallingMode[\"AUTO\"] = \"AUTO\";\n  // Model is constrained to always predicting a function call only.\n  // If \"allowed_function_names\" are set, the predicted function call will be\n  // limited to any one of \"allowed_function_names\", else the predicted\n  // function call will be any one of the provided \"function_declarations\".\n  FunctionCallingMode[\"ANY\"] = \"ANY\";\n  // Model will not predict any function call. Model behavior is same as when\n  // not passing any function declarations.\n  FunctionCallingMode[\"NONE\"] = \"NONE\";\n})(FunctionCallingMode || (FunctionCallingMode = {}));\n/**\n * The mode of the predictor to be used in dynamic retrieval.\n * @public\n */\nvar DynamicRetrievalMode;\n(function (DynamicRetrievalMode) {\n  // Unspecified function calling mode. This value should not be used.\n  DynamicRetrievalMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n  // Run retrieval only when system decides it is necessary.\n  DynamicRetrievalMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(DynamicRetrievalMode || (DynamicRetrievalMode = {}));\nexport { ExecutableCodeLanguage, FileState, FunctionCallingMode, GoogleAICacheManager, GoogleAIFileManager, Outcome, SchemaType };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import { readFileSync } from 'fs';\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Basic error type for this SDK.\n * @public\n */\nclass GoogleGenerativeAIError extends Error {\n    constructor(message) {\n        super(`[GoogleGenerativeAI Error]: ${message}`);\n    }\n}\n/**\n * Error class covering HTTP errors when calling the server. Includes HTTP\n * status, statusText, and optional details, if provided in the server response.\n * @public\n */\nclass GoogleGenerativeAIFetchError extends GoogleGenerativeAIError {\n    constructor(message, status, statusText, errorDetails) {\n        super(message);\n        this.status = status;\n        this.statusText = statusText;\n        this.errorDetails = errorDetails;\n    }\n}\n/**\n * Errors in the contents of a request originating from user input.\n * @public\n */\nclass GoogleGenerativeAIRequestInputError extends GoogleGenerativeAIError {\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_BASE_URL = \"https://generativelanguage.googleapis.com\";\nconst DEFAULT_API_VERSION = \"v1beta\";\n/**\n * We can't `require` package.json if this runs on web. We will use rollup to\n * swap in the version number here at build time.\n */\nconst PACKAGE_VERSION = \"0.21.0\";\nconst PACKAGE_LOG_HEADER = \"genai-js\";\nvar Task;\n(function (Task) {\n    Task[\"GENERATE_CONTENT\"] = \"generateContent\";\n    Task[\"STREAM_GENERATE_CONTENT\"] = \"streamGenerateContent\";\n    Task[\"COUNT_TOKENS\"] = \"countTokens\";\n    Task[\"EMBED_CONTENT\"] = \"embedContent\";\n    Task[\"BATCH_EMBED_CONTENTS\"] = \"batchEmbedContents\";\n})(Task || (Task = {}));\n/**\n * Simple, but may become more complex if we add more versions to log.\n */\nfunction getClientHeaders(requestOptions) {\n    const clientHeaders = [];\n    if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {\n        clientHeaders.push(requestOptions.apiClient);\n    }\n    clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);\n    return clientHeaders.join(\" \");\n}\nasync function makeRequest(url, fetchOptions, fetchFn = fetch) {\n    let response;\n    try {\n        response = await fetchFn(url, fetchOptions);\n    }\n    catch (e) {\n        handleResponseError(e, url);\n    }\n    if (!response.ok) {\n        await handleResponseNotOk(response, url);\n    }\n    return response;\n}\nfunction handleResponseError(e, url) {\n    let err = e;\n    if (!(e instanceof GoogleGenerativeAIFetchError ||\n        e instanceof GoogleGenerativeAIRequestInputError)) {\n        err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);\n        err.stack = e.stack;\n    }\n    throw err;\n}\nasync function handleResponseNotOk(response, url) {\n    let message = \"\";\n    let errorDetails;\n    try {\n        const json = await response.json();\n        message = json.error.message;\n        if (json.error.details) {\n            message += ` ${JSON.stringify(json.error.details)}`;\n            errorDetails = json.error.details;\n        }\n    }\n    catch (e) {\n        // ignored\n    }\n    throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar RpcTask;\n(function (RpcTask) {\n    RpcTask[\"UPLOAD\"] = \"upload\";\n    RpcTask[\"LIST\"] = \"list\";\n    RpcTask[\"GET\"] = \"get\";\n    RpcTask[\"DELETE\"] = \"delete\";\n    RpcTask[\"UPDATE\"] = \"update\";\n    RpcTask[\"CREATE\"] = \"create\";\n})(RpcTask || (RpcTask = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst taskToMethod = {\n    [RpcTask.UPLOAD]: \"POST\",\n    [RpcTask.LIST]: \"GET\",\n    [RpcTask.GET]: \"GET\",\n    [RpcTask.DELETE]: \"DELETE\",\n    [RpcTask.UPDATE]: \"PATCH\",\n    [RpcTask.CREATE]: \"POST\",\n};\nclass ServerRequestUrl {\n    constructor(task, apiKey, requestOptions) {\n        this.task = task;\n        this.apiKey = apiKey;\n        this.requestOptions = requestOptions;\n    }\n    appendPath(path) {\n        this._url.pathname = this._url.pathname + `/${path}`;\n    }\n    appendParam(key, value) {\n        this._url.searchParams.append(key, value);\n    }\n    toString() {\n        return this._url.toString();\n    }\n}\nclass CachedContentUrl extends ServerRequestUrl {\n    constructor(task, apiKey, requestOptions) {\n        var _a, _b;\n        super(task, apiKey, requestOptions);\n        this.task = task;\n        this.apiKey = apiKey;\n        this.requestOptions = requestOptions;\n        const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;\n        const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;\n        let initialUrl = baseUrl;\n        initialUrl += `/${apiVersion}/cachedContents`;\n        this._url = new URL(initialUrl);\n    }\n}\nclass FilesRequestUrl extends ServerRequestUrl {\n    constructor(task, apiKey, requestOptions) {\n        var _a, _b;\n        super(task, apiKey, requestOptions);\n        this.task = task;\n        this.apiKey = apiKey;\n        this.requestOptions = requestOptions;\n        const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;\n        const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;\n        let initialUrl = baseUrl;\n        if (this.task === RpcTask.UPLOAD) {\n            initialUrl += `/upload`;\n        }\n        initialUrl += `/${apiVersion}/files`;\n        this._url = new URL(initialUrl);\n    }\n}\nfunction getHeaders(url) {\n    const headers = new Headers();\n    headers.append(\"x-goog-api-client\", getClientHeaders(url.requestOptions));\n    headers.append(\"x-goog-api-key\", url.apiKey);\n    return headers;\n}\nasync function makeServerRequest(url, headers, body, fetchFn = fetch) {\n    const requestInit = {\n        method: taskToMethod[url.task],\n        headers,\n    };\n    if (body) {\n        requestInit.body = body;\n    }\n    const signal = getSignal(url.requestOptions);\n    if (signal) {\n        requestInit.signal = signal;\n    }\n    return makeRequest(url.toString(), requestInit, fetchFn);\n}\n/**\n * Create an AbortSignal based on the timeout and signal in the\n * RequestOptions.\n */\nfunction getSignal(requestOptions) {\n    if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) !== undefined || (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {\n        const controller = new AbortController();\n        if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {\n            setTimeout(() => controller.abort(), requestOptions.timeout);\n        }\n        if (requestOptions.signal) {\n            requestOptions.signal.addEventListener(\"abort\", () => {\n                controller.abort();\n            });\n        }\n        return controller.signal;\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Class for managing GoogleAI file uploads.\n * @public\n */\nclass GoogleAIFileManager {\n    constructor(apiKey, _requestOptions = {}) {\n        this.apiKey = apiKey;\n        this._requestOptions = _requestOptions;\n    }\n    /**\n     * Upload a file.\n     */\n    async uploadFile(filePath, fileMetadata) {\n        const file = readFileSync(filePath);\n        const url = new FilesRequestUrl(RpcTask.UPLOAD, this.apiKey, this._requestOptions);\n        const uploadHeaders = getHeaders(url);\n        const boundary = generateBoundary();\n        uploadHeaders.append(\"X-Goog-Upload-Protocol\", \"multipart\");\n        uploadHeaders.append(\"Content-Type\", `multipart/related; boundary=${boundary}`);\n        const uploadMetadata = getUploadMetadata(fileMetadata);\n        // Multipart formatting code taken from @firebase/storage\n        const metadataString = JSON.stringify({ file: uploadMetadata });\n        const preBlobPart = \"--\" +\n            boundary +\n            \"\\r\\n\" +\n            \"Content-Type: application/json; charset=utf-8\\r\\n\\r\\n\" +\n            metadataString +\n            \"\\r\\n--\" +\n            boundary +\n            \"\\r\\n\" +\n            \"Content-Type: \" +\n            fileMetadata.mimeType +\n            \"\\r\\n\\r\\n\";\n        const postBlobPart = \"\\r\\n--\" + boundary + \"--\";\n        const blob = new Blob([preBlobPart, file, postBlobPart]);\n        const response = await makeServerRequest(url, uploadHeaders, blob);\n        return response.json();\n    }\n    /**\n     * List all uploaded files.\n     *\n     * Any fields set in the optional {@link SingleRequestOptions} parameter will take\n     * precedence over the {@link RequestOptions} values provided at the time of the\n     * {@link GoogleAIFileManager} initialization.\n     */\n    async listFiles(listParams, requestOptions = {}) {\n        const filesRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        const url = new FilesRequestUrl(RpcTask.LIST, this.apiKey, filesRequestOptions);\n        if (listParams === null || listParams === void 0 ? void 0 : listParams.pageSize) {\n            url.appendParam(\"pageSize\", listParams.pageSize.toString());\n        }\n        if (listParams === null || listParams === void 0 ? void 0 : listParams.pageToken) {\n            url.appendParam(\"pageToken\", listParams.pageToken);\n        }\n        const uploadHeaders = getHeaders(url);\n        const response = await makeServerRequest(url, uploadHeaders);\n        return response.json();\n    }\n    /**\n     * Get metadata for file with given ID.\n     *\n     * Any fields set in the optional {@link SingleRequestOptions} parameter will take\n     * precedence over the {@link RequestOptions} values provided at the time of the\n     * {@link GoogleAIFileManager} initialization.\n     */\n    async getFile(fileId, requestOptions = {}) {\n        const filesRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);\n        const url = new FilesRequestUrl(RpcTask.GET, this.apiKey, filesRequestOptions);\n        url.appendPath(parseFileId(fileId));\n        const uploadHeaders = getHeaders(url);\n        const response = await makeServerRequest(url, uploadHeaders);\n        return response.json();\n    }\n    /**\n     * Delete file with given ID.\n     */\n    async deleteFile(fileId) {\n        const url = new FilesRequestUrl(RpcTask.DELETE, this.apiKey, this._requestOptions);\n        url.appendPath(parseFileId(fileId));\n        const uploadHeaders = getHeaders(url);\n        await makeServerRequest(url, uploadHeaders);\n    }\n}\n/**\n * If fileId is prepended with \"files/\", remove prefix\n */\nfunction parseFileId(fileId) {\n    if (fileId.startsWith(\"files/\")) {\n        return fileId.split(\"files/\")[1];\n    }\n    if (!fileId) {\n        throw new GoogleGenerativeAIError(`Invalid fileId ${fileId}. ` +\n            `Must be in the format \"files/filename\" or \"filename\"`);\n    }\n    return fileId;\n}\nfunction generateBoundary() {\n    let str = \"\";\n    for (let i = 0; i < 2; i++) {\n        str = str + Math.random().toString().slice(2);\n    }\n    return str;\n}\nfunction getUploadMetadata(inputMetadata) {\n    if (!inputMetadata.mimeType) {\n        throw new GoogleGenerativeAIRequestInputError(\"Must provide a mimeType.\");\n    }\n    const uploadMetadata = {\n        mimeType: inputMetadata.mimeType,\n        displayName: inputMetadata.displayName,\n    };\n    if (inputMetadata.name) {\n        uploadMetadata.name = inputMetadata.name.includes(\"/\")\n            ? inputMetadata.name\n            : `files/${inputMetadata.name}`;\n    }\n    return uploadMetadata;\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction formatSystemInstruction(input) {\n    // null or undefined\n    if (input == null) {\n        return undefined;\n    }\n    else if (typeof input === \"string\") {\n        return { role: \"system\", parts: [{ text: input }] };\n    }\n    else if (input.text) {\n        return { role: \"system\", parts: [input] };\n    }\n    else if (input.parts) {\n        if (!input.role) {\n            return { role: \"system\", parts: input.parts };\n        }\n        else {\n            return input;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Class for managing GoogleAI content caches.\n * @public\n */\nclass GoogleAICacheManager {\n    constructor(apiKey, _requestOptions) {\n        this.apiKey = apiKey;\n        this._requestOptions = _requestOptions;\n    }\n    /**\n     * Upload a new content cache\n     */\n    async create(createOptions) {\n        const newCachedContent = Object.assign({}, createOptions);\n        if (createOptions.ttlSeconds) {\n            if (createOptions.expireTime) {\n                throw new GoogleGenerativeAIRequestInputError(\"You cannot specify both `ttlSeconds` and `expireTime` when creating\" +\n                    \" a content cache. You must choose one.\");\n            }\n            if (createOptions.systemInstruction) {\n                newCachedContent.systemInstruction = formatSystemInstruction(createOptions.systemInstruction);\n            }\n            newCachedContent.ttl = createOptions.ttlSeconds.toString() + \"s\";\n            delete newCachedContent.ttlSeconds;\n        }\n        if (!newCachedContent.model) {\n            throw new GoogleGenerativeAIRequestInputError(\"Cached content must contain a `model` field.\");\n        }\n        if (!newCachedContent.model.includes(\"/\")) {\n            // If path is not included, assume it's a non-tuned model.\n            newCachedContent.model = `models/${newCachedContent.model}`;\n        }\n        const url = new CachedContentUrl(RpcTask.CREATE, this.apiKey, this._requestOptions);\n        const headers = getHeaders(url);\n        const response = await makeServerRequest(url, headers, JSON.stringify(newCachedContent));\n        return response.json();\n    }\n    /**\n     * List all uploaded content caches\n     */\n    async list(listParams) {\n        const url = new CachedContentUrl(RpcTask.LIST, this.apiKey, this._requestOptions);\n        if (listParams === null || listParams === void 0 ? void 0 : listParams.pageSize) {\n            url.appendParam(\"pageSize\", listParams.pageSize.toString());\n        }\n        if (listParams === null || listParams === void 0 ? void 0 : listParams.pageToken) {\n            url.appendParam(\"pageToken\", listParams.pageToken);\n        }\n        const headers = getHeaders(url);\n        const response = await makeServerRequest(url, headers);\n        return response.json();\n    }\n    /**\n     * Get a content cache\n     */\n    async get(name) {\n        const url = new CachedContentUrl(RpcTask.GET, this.apiKey, this._requestOptions);\n        url.appendPath(parseCacheName(name));\n        const headers = getHeaders(url);\n        const response = await makeServerRequest(url, headers);\n        return response.json();\n    }\n    /**\n     * Update an existing content cache\n     */\n    async update(name, updateParams) {\n        const url = new CachedContentUrl(RpcTask.UPDATE, this.apiKey, this._requestOptions);\n        url.appendPath(parseCacheName(name));\n        const headers = getHeaders(url);\n        const formattedCachedContent = Object.assign({}, updateParams.cachedContent);\n        if (updateParams.cachedContent.ttlSeconds) {\n            formattedCachedContent.ttl =\n                updateParams.cachedContent.ttlSeconds.toString() + \"s\";\n            delete formattedCachedContent.ttlSeconds;\n        }\n        if (updateParams.updateMask) {\n            url.appendParam(\"update_mask\", updateParams.updateMask.map((prop) => camelToSnake(prop)).join(\",\"));\n        }\n        const response = await makeServerRequest(url, headers, JSON.stringify(formattedCachedContent));\n        return response.json();\n    }\n    /**\n     * Delete content cache with given name\n     */\n    async delete(name) {\n        const url = new CachedContentUrl(RpcTask.DELETE, this.apiKey, this._requestOptions);\n        url.appendPath(parseCacheName(name));\n        const headers = getHeaders(url);\n        await makeServerRequest(url, headers);\n    }\n}\n/**\n * If cache name is prepended with \"cachedContents/\", remove prefix\n */\nfunction parseCacheName(name) {\n    if (name.startsWith(\"cachedContents/\")) {\n        return name.split(\"cachedContents/\")[1];\n    }\n    if (!name) {\n        throw new GoogleGenerativeAIError(`Invalid name ${name}. ` +\n            `Must be in the format \"cachedContents/name\" or \"name\"`);\n    }\n    return name;\n}\nfunction camelToSnake(str) {\n    return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\n\n/**\n * Processing state of the `File`.\n * @public\n */\nvar FileState;\n(function (FileState) {\n    // The default value. This value is used if the state is omitted.\n    FileState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    // File is being processed and cannot be used for inference yet.\n    FileState[\"PROCESSING\"] = \"PROCESSING\";\n    // File is processed and available for inference.\n    FileState[\"ACTIVE\"] = \"ACTIVE\";\n    // File failed processing.\n    FileState[\"FAILED\"] = \"FAILED\";\n})(FileState || (FileState = {}));\n\n/**\n * Contains the list of OpenAPI data types\n * as defined by https://swagger.io/docs/specification/data-models/data-types/\n * @public\n */\nvar SchemaType;\n(function (SchemaType) {\n    /** String type. */\n    SchemaType[\"STRING\"] = \"string\";\n    /** Number type. */\n    SchemaType[\"NUMBER\"] = \"number\";\n    /** Integer type. */\n    SchemaType[\"INTEGER\"] = \"integer\";\n    /** Boolean type. */\n    SchemaType[\"BOOLEAN\"] = \"boolean\";\n    /** Array type. */\n    SchemaType[\"ARRAY\"] = \"array\";\n    /** Object type. */\n    SchemaType[\"OBJECT\"] = \"object\";\n})(SchemaType || (SchemaType = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @public\n */\nvar ExecutableCodeLanguage;\n(function (ExecutableCodeLanguage) {\n    ExecutableCodeLanguage[\"LANGUAGE_UNSPECIFIED\"] = \"language_unspecified\";\n    ExecutableCodeLanguage[\"PYTHON\"] = \"python\";\n})(ExecutableCodeLanguage || (ExecutableCodeLanguage = {}));\n/**\n * Possible outcomes of code execution.\n * @public\n */\nvar Outcome;\n(function (Outcome) {\n    /**\n     * Unspecified status. This value should not be used.\n     */\n    Outcome[\"OUTCOME_UNSPECIFIED\"] = \"outcome_unspecified\";\n    /**\n     * Code execution completed successfully.\n     */\n    Outcome[\"OUTCOME_OK\"] = \"outcome_ok\";\n    /**\n     * Code execution finished but with a failure. `stderr` should contain the\n     * reason.\n     */\n    Outcome[\"OUTCOME_FAILED\"] = \"outcome_failed\";\n    /**\n     * Code execution ran for too long, and was cancelled. There may or may not\n     * be a partial output present.\n     */\n    Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"outcome_deadline_exceeded\";\n})(Outcome || (Outcome = {}));\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Possible roles.\n * @public\n */\n/**\n * Harm categories that would cause prompts or candidates to be blocked.\n * @public\n */\nvar HarmCategory;\n(function (HarmCategory) {\n    HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n})(HarmCategory || (HarmCategory = {}));\n/**\n * Threshold above which a prompt or candidate will be blocked.\n * @public\n */\nvar HarmBlockThreshold;\n(function (HarmBlockThreshold) {\n    // Threshold is unspecified.\n    HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    // Content with NEGLIGIBLE will be allowed.\n    HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    // Content with NEGLIGIBLE and LOW will be allowed.\n    HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    // Content with NEGLIGIBLE, LOW, and MEDIUM will be allowed.\n    HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    // All content will be allowed.\n    HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(HarmBlockThreshold || (HarmBlockThreshold = {}));\n/**\n * Probability that a prompt or candidate matches a harm category.\n * @public\n */\nvar HarmProbability;\n(function (HarmProbability) {\n    // Probability is unspecified.\n    HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    // Content has a negligible chance of being unsafe.\n    HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    // Content has a low chance of being unsafe.\n    HarmProbability[\"LOW\"] = \"LOW\";\n    // Content has a medium chance of being unsafe.\n    HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    // Content has a high chance of being unsafe.\n    HarmProbability[\"HIGH\"] = \"HIGH\";\n})(HarmProbability || (HarmProbability = {}));\n/**\n * Reason that a prompt was blocked.\n * @public\n */\nvar BlockReason;\n(function (BlockReason) {\n    // A blocked reason was not specified.\n    BlockReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    // Content was blocked by safety settings.\n    BlockReason[\"SAFETY\"] = \"SAFETY\";\n    // Content was blocked, but the reason is uncategorized.\n    BlockReason[\"OTHER\"] = \"OTHER\";\n})(BlockReason || (BlockReason = {}));\n/**\n * Reason that a candidate finished.\n * @public\n */\nvar FinishReason;\n(function (FinishReason) {\n    // Default value. This value is unused.\n    FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    // Natural stop point of the model or provided stop sequence.\n    FinishReason[\"STOP\"] = \"STOP\";\n    // The maximum number of tokens as specified in the request was reached.\n    FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    // The candidate content was flagged for safety reasons.\n    FinishReason[\"SAFETY\"] = \"SAFETY\";\n    // The candidate content was flagged for recitation reasons.\n    FinishReason[\"RECITATION\"] = \"RECITATION\";\n    // The candidate content was flagged for using an unsupported language.\n    FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    // Unknown reason.\n    FinishReason[\"OTHER\"] = \"OTHER\";\n})(FinishReason || (FinishReason = {}));\n/**\n * Task type for embedding content.\n * @public\n */\nvar TaskType;\n(function (TaskType) {\n    TaskType[\"TASK_TYPE_UNSPECIFIED\"] = \"TASK_TYPE_UNSPECIFIED\";\n    TaskType[\"RETRIEVAL_QUERY\"] = \"RETRIEVAL_QUERY\";\n    TaskType[\"RETRIEVAL_DOCUMENT\"] = \"RETRIEVAL_DOCUMENT\";\n    TaskType[\"SEMANTIC_SIMILARITY\"] = \"SEMANTIC_SIMILARITY\";\n    TaskType[\"CLASSIFICATION\"] = \"CLASSIFICATION\";\n    TaskType[\"CLUSTERING\"] = \"CLUSTERING\";\n})(TaskType || (TaskType = {}));\n/**\n * @public\n */\nvar FunctionCallingMode;\n(function (FunctionCallingMode) {\n    // Unspecified function calling mode. This value should not be used.\n    FunctionCallingMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    // Default model behavior, model decides to predict either a function call\n    // or a natural language repspose.\n    FunctionCallingMode[\"AUTO\"] = \"AUTO\";\n    // Model is constrained to always predicting a function call only.\n    // If \"allowed_function_names\" are set, the predicted function call will be\n    // limited to any one of \"allowed_function_names\", else the predicted\n    // function call will be any one of the provided \"function_declarations\".\n    FunctionCallingMode[\"ANY\"] = \"ANY\";\n    // Model will not predict any function call. Model behavior is same as when\n    // not passing any function declarations.\n    FunctionCallingMode[\"NONE\"] = \"NONE\";\n})(FunctionCallingMode || (FunctionCallingMode = {}));\n/**\n * The mode of the predictor to be used in dynamic retrieval.\n * @public\n */\nvar DynamicRetrievalMode;\n(function (DynamicRetrievalMode) {\n    // Unspecified function calling mode. This value should not be used.\n    DynamicRetrievalMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    // Run retrieval only when system decides it is necessary.\n    DynamicRetrievalMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(DynamicRetrievalMode || (DynamicRetrievalMode = {}));\n\nexport { ExecutableCodeLanguage, FileState, FunctionCallingMode, GoogleAICacheManager, GoogleAIFileManager, Outcome, SchemaType };\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}